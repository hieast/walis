# SOA
------

## 结构图解

![Walis SOA 结构图解](./SOA.png)

## 主要层次说明

如图所示，越下层提供的接口越原子化。<font color=red>上层可以调用直接下层，但是不能跨层调用；下层绝对禁止调用上层。</font>

1. <b>Model/Zeus/Redis/Mongo</b>
    
    > 描述:
    > 主要封装对数据库层的最基础的CURD，还有zeus提供的原子性接口。该层只关心数据的来源，不关心数据的多少和去向。
    

2. <b>Inner</b>
    
    > 描述:
    > 主要封装下层，即Model/Zeus等数据来源，提供统一的数据出口
    
    注意:
    * 该层不能包含任何业务逻辑，也不应该抛任何业务异常
    * 对于可能引发异常的情况下，正常逻辑返回真实数据，异常逻辑返回None
    * 对于较重的一些query可从model单独抽取出来

3. <b>Service</b>

    > 描述:
    > 该层封装对外业务，针对每个业务功能来开设相应的对外服务
    
    创建开发一个新功能的一般流程:
    1. 从产品原型中分析业务功能
    2. 对该业务进行建模，包括对外开放的所有接口定义(此时不包含具体实现)
    3. 所有相关后端开发者对该业务模型进行评审
    4. 根据评审结果修正模型，正式进入开发
    
    注意:
    * Service层应当根据Inner层返回数据做判断，对于异常数据必须在该层抛出业务异常。
    * Service层不应当调用类似`current_user`等依赖于HTTP的属性，对于需要记录当前用户的接口，需要添加对应参数，例如`user_id`，用户真实数据由下层获取。
    * 对上层提供的数据格式应该统一

4. <b>对外服务:API</b>
     
    > 描述:
    > 该层只负责解析参数，做必要的业务封装，核心业务逻辑应下沉至service层。
    > 与下层交互时，由框架层统一做必要的数据类型转换。
    
    * HTTP(WebService...)
    
        * dispatch层实现对url的分发
        * handler层实现对Http请求参数的获取和转换返回数据
        
    * RPC(Thrift...) 
    
        * dispatch层实现函数的分发
        * handler层实现对数据的转换
        
## Example
参考 `cs` 模块
